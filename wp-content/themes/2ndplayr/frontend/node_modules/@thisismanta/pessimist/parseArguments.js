"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const camelCase_1 = __importDefault(require("lodash/camelCase"));
const words_1 = __importDefault(require("lodash/words"));
function parseArguments(inputs, defaultHash, options) {
    const [positionalArguments, namedArguments] = inputs
        .filter(input => /^-+$/.test(input) === false)
        .reduce(([positionalArguments, namedArguments], input) => {
        if (/^--?\w/.test(input)) {
            const delimiterIndex = input.indexOf('=');
            const actualName = delimiterIndex === -1 ? input : input.substring(0, delimiterIndex);
            const { formalName, negated } = getFormalName(actualName, defaultHash);
            const alias = options?.aliases?.find(([aliasName]) => aliasName === formalName)?.[1]?.toString();
            const value = delimiterIndex === -1 ? undefined : input.substring(delimiterIndex + 1);
            namedArguments.push({
                field: alias || formalName,
                negated,
                value,
                input,
            });
        }
        else {
            positionalArguments.push(input);
        }
        return [positionalArguments, namedArguments];
    }, [[], []]);
    const outputHash = Object.assign({}, defaultHash);
    for (const { field, negated, value, input } of namedArguments) {
        const defaultValue = defaultHash[field];
        if (defaultValue === undefined) {
            throw new Error(`Unexpected "${input}" as it was not defined in the default hash.`);
        }
        if (typeof defaultValue === 'boolean') {
            const derivedValue = (() => {
                if (value === undefined)
                    return true;
                if (value === '')
                    return false;
                if (/^(false|0|n|no|off)$/i.test(value.trim()))
                    return false;
                return true;
            })();
            outputHash[field] = negated ? !derivedValue : derivedValue;
        }
        else if (typeof defaultValue === 'number') {
            if (negated) {
                if (value) {
                    throw new Error(`Unexpected "${input}" to have a value.`);
                }
                else {
                    outputHash[field] = defaultHash[field];
                }
            }
            else {
                outputHash[field] = value === undefined ? NaN : parseFloat(value);
            }
        }
        else if (typeof defaultValue === 'string') {
            if (negated) {
                if (value === undefined || outputHash[field] === value) {
                    outputHash[field] = '';
                }
            }
            else if (value === undefined) {
                throw new Error(`Expected "${input}" to have a value.`);
            }
            else {
                outputHash[field] = value;
            }
        }
        else if (Array.isArray(defaultValue)) {
            if (negated) {
                if (value === undefined) {
                    outputHash[field] = [];
                }
                else {
                    outputHash[field] = difference(outputHash[field], [value]);
                }
            }
            else {
                if (value === undefined) {
                    throw new Error(`Expected "${input}" to have a value.`);
                }
                if (outputHash[field].includes(value)) {
                    outputHash[field] = difference(outputHash[field], [value]);
                }
                outputHash[field] = [...outputHash[field], value];
            }
        }
    }
    if (options?.exclusives) {
        const fields = Array.from(new Set(namedArguments.map(({ field }) => field)));
        const fieldInputMap = Object.fromEntries(namedArguments.map(({ field, input }) => [field, input]));
        for (const group of options.exclusives) {
            const intersections = intersect(group, fields);
            if (intersections.length > 1) {
                throw new Error('Unexpected ' + intersections.map(field => '"' + fieldInputMap[field] + '"').join(' and ') + ' to exist at the same time as they are mutually exclusive.');
            }
        }
    }
    return Object.assign(outputHash, positionalArguments, { length: positionalArguments.length });
}
exports.default = parseArguments;
function getFormalName(possiblyDirtyName, defaults) {
    const wordList = (0, words_1.default)(possiblyDirtyName);
    const formalName = (0, camelCase_1.default)(possiblyDirtyName);
    if (wordList[0] === 'no' && !(formalName in defaults)) {
        return {
            formalName: (0, camelCase_1.default)(wordList.slice(1).join('-')),
            negated: true
        };
    }
    if (wordList[0] !== 'no' && (0, camelCase_1.default)('no-' + possiblyDirtyName) in defaults) {
        return {
            formalName: (0, camelCase_1.default)('no-' + possiblyDirtyName),
            negated: true
        };
    }
    return {
        formalName,
        negated: false
    };
}
function difference(sourceList, subtractorList) {
    return sourceList.filter(item => !subtractorList.includes(item));
}
function intersect(sourceList, comparingList) {
    return sourceList.filter(item => comparingList.includes(item));
}
